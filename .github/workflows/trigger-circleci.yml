name: CircleCI build docs after pre-commit
# This workflow was written with help from the Google Gemini generative AI tool

permissions:
  statuses: read

on:
  # Trigger the workflow when a PR is opened, reopened, or has a new commit
  pull_request:
    types: [opened, reopened, synchronize]

jobs:
  trigger_circleci_after_precommit:
    # This should make sure that the workflow isn't properly triggered if the contributor added the
    #  'skip-doc-build' label prior to submitting the PR.
    if: contains( github.event.pull_request.labels.*.name, 'skip-doc-build') == false

    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Wait for 'pre-commit.ci' to pass
        # This action repeatedly polls the GitHub Statuses API for the specific check.
        uses: "nick-fields/retry@v3.0.2"
        id: retry_check
        with:
          timeout_seconds: 600 # Wait up to 10 minutes
          max_attempts: 10
          retry_wait_seconds: 20 # Wait 20 seconds between checks seconds
          retry_on_exit_code: 3
          command: |
            # Get the API URL for the PR's commit statuses
            STATUS_URL="${{ github.event.pull_request.statuses_url }}"
            echo $STATUS_URL

            # Fetch statuses, find the 'pre-commit.ci/commit-status', and extract its state
            STATUS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "${STATUS_URL}" | jq -r '
            map(select(.context == "pre-commit.ci - pr"))
            | sort_by(.updated_at)
            | last
            | .state // empty
            ')

            echo "Current pre-commit.ci status: $STATUS"

            # If the status is failure then we're going to exit with error code 1, but if
            #  the status is anything else, other than 'success', we'll exit with code 3, which
            #  the retry action will interpret as a retryable failure.
            if [ "$STATUS" == "failure" ]; then
              exit 1
            elif [ "$STATUS" != "success" ]; then
              exit 3
            fi

      - name: Define notebook build list
        id: notebooks
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Define the exclude patterns (must match conf.py BASE_EXCLUDE_PATTERNS)
          EXCLUDE_PATTERNS=("*notebook_template*" "*pull_request_template*" "*README*" "**/*README*" "*.ipynb_checkpoints*")

          # First, check if there's an override pattern in PR comments
          OVERRIDE_NOTEBOOKS=$(curl -s \
            -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" | \
            jq -r '.[] | select(.body | contains("@heasarc-notebooks:")) | .body | match("@heasarc-notebooks:\\s*(.+)"; "g") | .captures[0].string' | tail -1)

          if [ -n "$OVERRIDE_NOTEBOOKS" ]; then
            # Use the override from comments
            NOTEBOOKS_TO_BUILD="$OVERRIDE_NOTEBOOKS"
            echo "Using notebooks specified in PR comment: $NOTEBOOKS_TO_BUILD"
          else
            # Get the list of changed files in the PR
            CHANGED_FILES=$(git diff --name-only origin/main...HEAD)

            # Filter and process the files
            NOTEBOOKS_TO_BUILD=""
            while IFS= read -r file; do
              # Check if file is in tutorials directory and ends with .md
              if [[ "$file" =~ ^tutorials/.*\.md$ ]]; then
                # Get relative path from tutorials directory
                REL_PATH="${file#tutorials/}"

                # Check if file should be excluded
                SHOULD_EXCLUDE=false
                for pattern in "${EXCLUDE_PATTERNS[@]}"; do
                  # Convert glob patterns to match logic
                  if [[ "$REL_PATH" == *"index"* ]] || [[ "$REL_PATH" =~ $(echo "$pattern" | sed 's/\*/.*/'g) ]]; then
                    SHOULD_EXCLUDE=true
                    break
                  fi
                done

                if [ "$SHOULD_EXCLUDE" = false ]; then
                  if [ -z "$NOTEBOOKS_TO_BUILD" ]; then
                    NOTEBOOKS_TO_BUILD="$REL_PATH"
                  else
                    NOTEBOOKS_TO_BUILD="${NOTEBOOKS_TO_BUILD},$REL_PATH"
                  fi
                fi
              fi
            done <<< "$CHANGED_FILES"

            echo "Notebooks to build based on changed files: $NOTEBOOKS_TO_BUILD"
          fi

          # Export the variable for the next step
          echo "notebooks_to_build=$NOTEBOOKS_TO_BUILD" >> $GITHUB_OUTPUT


      - name: Trigger CircleCI Pipeline via API
        # Only proceed if the wait step succeeded, and the 'skip-doc-build' label wasn't added to the PR (could be
        #  that the contributor added the label after the PR was opened).
        if: success() && contains( github.event.pull_request.labels.*.name, 'skip-doc-build') == false
        env:
          # At the time of writing, this call will only work using personal API access tokens, rather than
          #  organization-level tokens.
          CIRCLE_TOKEN: ${{ secrets.DAVID_CIRCLECI_APIV2_PERSONAL_TOKEN }}
          TARGET_BRANCH: ${{ github.head_ref }}
          PROJECT_SLUG: 'circleci/LdzbTUR6aexSM6vJCVrZk5/GRoaAeYuJNgCdifZviG612'
          CHECKOUT_REPO: 'HEASARC/heasarc-tutorials'
        run: |
          echo "pre-commit.ci checks passed on branch ${TARGET_BRANCH}. Triggering CircleCI."
          echo "Notebooks to build: ${NOTEBOOKS_TO_BUILD}"

          # Post request to CircleCI API v2 to trigger a new pipeline
          # We pass arguments to the pipeline via the 'parameters' field, which
          #  allows us to control exactly which notebooks are to built.
          #curl -X POST \
          #  --url "https://circleci.com/api/v2/project/${PROJECT_SLUG}/pipeline/run" \
          #  --header "Content-Type: application/json" \
          #  --header "Circle-Token: ${CIRCLE_TOKEN}" \
          #  --data '{
          #    "definition_id": "f5bf0ced-00cd-4643-aa02-c2f10e445243",
          #    "config": {"branch": "'"${TARGET_BRANCH}"'"},
          #    "checkout": {"branch": "'"${TARGET_BRANCH}"'"},
          #    "parameters": {
          #      "notebooks_to_build": "'"${NOTEBOOKS_TO_BUILD}"'"
          #    }
          #   }'
